{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"gettake Get and save images from webcomicgamma Note: Redistribution of downloaded image data is prohibited. Please keep it to private use. Install pip install gettake OR: pipx install gettake Run $ gettake https://webcomicgamma . takeshobo . co . jp/manga/madeinabyss/ [ + ] Target: https://webcomicgamma . takeshobo . co . jp/manga/madeinabyss/ [ + ] Host: webcomicgamma . takeshobo . co . jp [ + ] Slug: madeinabyss [ + ] 0072 chapter(s) found! [ - ] Now: '001' [ 0001 / 0072 ] ..... saved! [ - ] Now: '002' [ 0002 / 0072 ] ..... saved! [ - ] Now: '003' [ 0003 / 0072 ] ..... saved! ... [ + ] Done! $ tree - dL 1 . /madeinabyss . /madeinabyss \u251c\u2500\u2500 001 \u251c\u2500\u2500 002 \u251c\u2500\u2500 003 ... \u2514\u2500\u2500 067 73 directories Help $ gettake - h usage : gettake [ - h ] [ - d DIR ] [ - o ] [ - q ] [ - V ] url Get and save images from webcomicgamma . positional arguments : url target url options : - h , -- help show this help message and exit - d DIR , -- save - dir DIR directory to save downloaded images ( default : . ) - o , -- overwrite overwrite ( default : False ) - q , -- quiet keep stdout quiet ( default : False ) - V , -- version show program 's version number and exit available urls : - https : // webcomicgamma . takeshobo . co . jp License MIT","title":"Home"},{"location":"#gettake","text":"Get and save images from webcomicgamma Note: Redistribution of downloaded image data is prohibited. Please keep it to private use.","title":"gettake"},{"location":"#install","text":"pip install gettake OR: pipx install gettake","title":"Install"},{"location":"#run","text":"$ gettake https://webcomicgamma . takeshobo . co . jp/manga/madeinabyss/ [ + ] Target: https://webcomicgamma . takeshobo . co . jp/manga/madeinabyss/ [ + ] Host: webcomicgamma . takeshobo . co . jp [ + ] Slug: madeinabyss [ + ] 0072 chapter(s) found! [ - ] Now: '001' [ 0001 / 0072 ] ..... saved! [ - ] Now: '002' [ 0002 / 0072 ] ..... saved! [ - ] Now: '003' [ 0003 / 0072 ] ..... saved! ... [ + ] Done! $ tree - dL 1 . /madeinabyss . /madeinabyss \u251c\u2500\u2500 001 \u251c\u2500\u2500 002 \u251c\u2500\u2500 003 ... \u2514\u2500\u2500 067 73 directories","title":"Run"},{"location":"#help","text":"$ gettake - h usage : gettake [ - h ] [ - d DIR ] [ - o ] [ - q ] [ - V ] url Get and save images from webcomicgamma . positional arguments : url target url options : - h , -- help show this help message and exit - d DIR , -- save - dir DIR directory to save downloaded images ( default : . ) - o , -- overwrite overwrite ( default : False ) - q , -- quiet keep stdout quiet ( default : False ) - V , -- version show program 's version number and exit available urls : - https : // webcomicgamma . takeshobo . co . jp","title":"Help"},{"location":"#license","text":"MIT","title":"License"},{"location":"reference/gettake/","text":"Module gettake View Source __version__ = \"0.2.0\" Sub-modules gettake.gettake gettake.main gettake.models","title":"Index"},{"location":"reference/gettake/#module-gettake","text":"View Source __version__ = \"0.2.0\"","title":"Module gettake"},{"location":"reference/gettake/#sub-modules","text":"gettake.gettake gettake.main gettake.models","title":"Sub-modules"},{"location":"reference/gettake/gettake/","text":"Module gettake.gettake Get and save images by chapters from specified work page. View Source \"\"\"Get and save images by chapters from specified work page.\"\"\" from __future__ import annotations import re from io import BytesIO from PIL import Image from requests import Session from .models import Option , PositionOfImage _UA = \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36\" def __get_page ( ptimg : PositionOfImage , image : Image . Image ) -> Image . Image : \"\"\"Get a page image from ptimg and image. Args: ptimg (PositionOfImage): ptimg.json image (Image.Image): scrumbled image data. Returns: Image.Image: decoded image \"\"\" view = ptimg [ \"views\" ][ 0 ] decoded_image = Image . new ( \"RGB\" , ( view [ \"width\" ], view [ \"height\" ])) pattern = re . compile ( r \"\"\"^ i:(?P<sx>\\d+),(?P<sy>\\d+) \\+ (?P<sxoff>\\d+),(?P<syoff>\\d+) \\> (?P<dx>\\d+),(?P<dy>\\d+) $\"\"\" , re . X , ) for coord in view [ \"coords\" ]: m = pattern . match ( coord ) if not m : raise ValueError ( f \" { coord !r} is not matched with expected pattern.\" ) ( sx , sy , sxoff , syoff , dx , dy , ) = ( int ( m [ \"sx\" ]), int ( m [ \"sy\" ]), int ( m [ \"sxoff\" ]), int ( m [ \"syoff\" ]), int ( m [ \"dx\" ]), int ( m [ \"dy\" ]), ) decoded_image . paste ( image . crop ( ( sx , sy , sx + sxoff , sy + syoff , ), ), ( dx , dy ), ) return decoded_image def __get_pages ( opt : Option , chapter : str , session : Session ) -> bool : \"\"\"Get pages from specified chapter. Args: opt (Option): cli options. chapter (str): chapter name. session (Session): requests session. Raises: ValueError: if image response is not ok. Returns: bool: True if saved, False if skipped. \"\"\" chapter_dir = opt . save_dir / chapter if chapter_dir . is_dir () and not opt . overwrite : return False chapter_dir . mkdir ( exist_ok = True , parents = True ) base_url = opt . get_file_url ( chapter ) for page_idx in range ( 1 , 10000 ): page = f \" { page_idx : 04 } \" ptimg_res = session . get ( f \" { base_url } / { page } .ptimg.json\" ) if not ptimg_res . ok : break image_res = session . get ( f \" { base_url } / { page } .jpg\" ) if not image_res . ok : raise ValueError ( f \" { image_res . url !r} returns { image_res . status_code } \" ) __get_page ( ptimg_res . json (), Image . open ( BytesIO ( image_res . content )), ) . save ( chapter_dir / f \" { page } .png\" , ) return True def __get_chapters ( source : str ) -> list [ str ]: \"\"\"Get chapters from source. Args: source (str): source of the page. Returns: list[str]: chapters. \"\"\" return sorted ( { m . group () for m in re . finditer ( r '(?<=_epi)(\\d+(?:_\\d+)*)(?=\")' , source , ) }, ) def get_images ( opt : Option ) -> None : \"\"\"Get images from specified url. Args: opt (Option): cli options. \"\"\" opt . save_dir /= opt . get_slug () opt . save_dir . mkdir ( exist_ok = True , parents = True ) session = Session () session . headers = { \"user-agent\" : _UA } chapters = __get_chapters ( session . get ( opt . url . geturl ()) . text ) chapters_len = len ( chapters ) print ( f \"[+] { chapters_len : 04 } chapter(s) found!\" ) # noqa: T201 for idx , chapter in enumerate ( chapters ): if not opt . quiet : print ( f \"[-] Now: { chapter !r} [ { idx + 1 : 04 } / { chapters_len : 04 } ] ...\" , end = \"\" , flush = True , ) # noqa: T201 skipped = __get_pages ( opt , chapter , session ) if not opt . quiet : print ( \"..saved!\" if skipped else \"skipped!\" ) # noqa: T201 session . close () __all__ = ( \"get_images\" ,) Functions get_images def get_images ( opt : 'Option' ) -> 'None' Get images from specified url. Parameters: Name Type Description Default opt Option cli options. None View Source def get_images(opt: Option) - > None: \"\"\"Get images from specified url . Args: opt (Option): cli options . \"\"\" opt . save_dir /= opt . get_slug() opt . save_dir . mkdir(exist_ok=True , parents=True) session = Session() session . headers = {\"user - agent\": _UA} chapters = __get_chapters(session . get(opt . url . geturl()) . text) chapters_len = len(chapters) print(f\" [ + ] {chapters_len:04} chapter(s) found!\") # noqa: T201 for idx , chapter in enumerate(chapters): if not opt . quiet: print( f\" [ - ] Now: {chapter!r} [ {idx + 1:04} / {chapters_len:04} ] ... \" , end=\"\" , flush=True , ) # noqa: T201 skipped = __get_pages(opt , chapter , session) if not opt . quiet: print(\" .. saved!\" if skipped else \"skipped!\") # noqa: T201 session . close()","title":"Gettake"},{"location":"reference/gettake/gettake/#module-gettakegettake","text":"Get and save images by chapters from specified work page. View Source \"\"\"Get and save images by chapters from specified work page.\"\"\" from __future__ import annotations import re from io import BytesIO from PIL import Image from requests import Session from .models import Option , PositionOfImage _UA = \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36\" def __get_page ( ptimg : PositionOfImage , image : Image . Image ) -> Image . Image : \"\"\"Get a page image from ptimg and image. Args: ptimg (PositionOfImage): ptimg.json image (Image.Image): scrumbled image data. Returns: Image.Image: decoded image \"\"\" view = ptimg [ \"views\" ][ 0 ] decoded_image = Image . new ( \"RGB\" , ( view [ \"width\" ], view [ \"height\" ])) pattern = re . compile ( r \"\"\"^ i:(?P<sx>\\d+),(?P<sy>\\d+) \\+ (?P<sxoff>\\d+),(?P<syoff>\\d+) \\> (?P<dx>\\d+),(?P<dy>\\d+) $\"\"\" , re . X , ) for coord in view [ \"coords\" ]: m = pattern . match ( coord ) if not m : raise ValueError ( f \" { coord !r} is not matched with expected pattern.\" ) ( sx , sy , sxoff , syoff , dx , dy , ) = ( int ( m [ \"sx\" ]), int ( m [ \"sy\" ]), int ( m [ \"sxoff\" ]), int ( m [ \"syoff\" ]), int ( m [ \"dx\" ]), int ( m [ \"dy\" ]), ) decoded_image . paste ( image . crop ( ( sx , sy , sx + sxoff , sy + syoff , ), ), ( dx , dy ), ) return decoded_image def __get_pages ( opt : Option , chapter : str , session : Session ) -> bool : \"\"\"Get pages from specified chapter. Args: opt (Option): cli options. chapter (str): chapter name. session (Session): requests session. Raises: ValueError: if image response is not ok. Returns: bool: True if saved, False if skipped. \"\"\" chapter_dir = opt . save_dir / chapter if chapter_dir . is_dir () and not opt . overwrite : return False chapter_dir . mkdir ( exist_ok = True , parents = True ) base_url = opt . get_file_url ( chapter ) for page_idx in range ( 1 , 10000 ): page = f \" { page_idx : 04 } \" ptimg_res = session . get ( f \" { base_url } / { page } .ptimg.json\" ) if not ptimg_res . ok : break image_res = session . get ( f \" { base_url } / { page } .jpg\" ) if not image_res . ok : raise ValueError ( f \" { image_res . url !r} returns { image_res . status_code } \" ) __get_page ( ptimg_res . json (), Image . open ( BytesIO ( image_res . content )), ) . save ( chapter_dir / f \" { page } .png\" , ) return True def __get_chapters ( source : str ) -> list [ str ]: \"\"\"Get chapters from source. Args: source (str): source of the page. Returns: list[str]: chapters. \"\"\" return sorted ( { m . group () for m in re . finditer ( r '(?<=_epi)(\\d+(?:_\\d+)*)(?=\")' , source , ) }, ) def get_images ( opt : Option ) -> None : \"\"\"Get images from specified url. Args: opt (Option): cli options. \"\"\" opt . save_dir /= opt . get_slug () opt . save_dir . mkdir ( exist_ok = True , parents = True ) session = Session () session . headers = { \"user-agent\" : _UA } chapters = __get_chapters ( session . get ( opt . url . geturl ()) . text ) chapters_len = len ( chapters ) print ( f \"[+] { chapters_len : 04 } chapter(s) found!\" ) # noqa: T201 for idx , chapter in enumerate ( chapters ): if not opt . quiet : print ( f \"[-] Now: { chapter !r} [ { idx + 1 : 04 } / { chapters_len : 04 } ] ...\" , end = \"\" , flush = True , ) # noqa: T201 skipped = __get_pages ( opt , chapter , session ) if not opt . quiet : print ( \"..saved!\" if skipped else \"skipped!\" ) # noqa: T201 session . close () __all__ = ( \"get_images\" ,)","title":"Module gettake.gettake"},{"location":"reference/gettake/gettake/#functions","text":"","title":"Functions"},{"location":"reference/gettake/gettake/#get_images","text":"def get_images ( opt : 'Option' ) -> 'None' Get images from specified url. Parameters: Name Type Description Default opt Option cli options. None View Source def get_images(opt: Option) - > None: \"\"\"Get images from specified url . Args: opt (Option): cli options . \"\"\" opt . save_dir /= opt . get_slug() opt . save_dir . mkdir(exist_ok=True , parents=True) session = Session() session . headers = {\"user - agent\": _UA} chapters = __get_chapters(session . get(opt . url . geturl()) . text) chapters_len = len(chapters) print(f\" [ + ] {chapters_len:04} chapter(s) found!\") # noqa: T201 for idx , chapter in enumerate(chapters): if not opt . quiet: print( f\" [ - ] Now: {chapter!r} [ {idx + 1:04} / {chapters_len:04} ] ... \" , end=\"\" , flush=True , ) # noqa: T201 skipped = __get_pages(opt , chapter , session) if not opt . quiet: print(\" .. saved!\" if skipped else \"skipped!\") # noqa: T201 session . close()","title":"get_images"},{"location":"reference/gettake/main/","text":"Module gettake.main Main module for gettake. View Source \"\"\"Main module for gettake.\"\"\" from __future__ import annotations import re import sys from argparse import ( ArgumentDefaultsHelpFormatter , ArgumentParser , ArgumentTypeError , RawDescriptionHelpFormatter , ) from pathlib import Path from shutil import get_terminal_size from typing import TYPE_CHECKING from urllib.parse import urlparse from . import __version__ from .gettake import get_images from .models import Option if TYPE_CHECKING : from urllib.parse import ParseResult VALID_HOSTS = ( \"webcomicgamma.takeshobo.co.jp\" ,) class CustomFormatter ( ArgumentDefaultsHelpFormatter , RawDescriptionHelpFormatter ): \"\"\"Custom formatter for argparse.\"\"\" def available_list () -> str : \"\"\"Return available urls. Returns: str: available urls. \"\"\" return \"available urls: \\n - https://\" + \" \\n - https://\" . join ( VALID_HOSTS ) def check_url ( s : str ) -> ParseResult : \"\"\"Check if s is a valid url. Args: s (str): url to check. Raises: argparse.ArgumentTypeError: if s is invalid. Returns: ParseResult: url object. \"\"\" url = urlparse ( s ) if url . hostname in VALID_HOSTS and re . match ( \"^/manga/[^/]+/?$\" , url . path ): return url raise ArgumentTypeError ( f \"' { s } ' is invalid. \\n \" + available_list ()) def check_dir ( s : str ) -> Path : \"\"\"Check if s is a valid directory. Args: s (str): path to check. Raises: argparse.ArgumentTypeError: if s is not a directory. Returns: Path: path object. \"\"\" if s == \".\" : return Path () . cwd () path = Path ( s ) if not path . is_dir (): raise ArgumentTypeError ( f \" { s !r} is not dir.\" ) return path def parse_args ( test : list [ str ] | None = None ) -> Option : \"\"\"Parse arguments. Args: test (list[str] | None): test args. Defaults to None. Returns: Option: cli options. Raises: ArgumentTypeError: if url is invalid. \"\"\" parser = ArgumentParser ( formatter_class = ( lambda prog : CustomFormatter ( prog , width = get_terminal_size ( fallback = ( 120 , 50 )) . columns , max_help_position = 25 , ) ), description = \"Get and save images from webcomicgamma.\" , epilog = available_list (), ) parser . add_argument ( \"url\" , metavar = \"url\" , type = check_url , help = \"target url\" , ) parser . add_argument ( \"-d\" , \"--save-dir\" , type = check_dir , metavar = \"DIR\" , default = \".\" , help = \"directory to save downloaded images\" , ) parser . add_argument ( \"-o\" , \"--overwrite\" , action = \"store_true\" , help = \"overwrite\" , ) parser . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" , help = \"keep stdout quiet\" , ) parser . add_argument ( \"-V\" , \"--version\" , action = \"version\" , version = __version__ ) if test : args = parser . parse_args ( test ) if len ( sys . argv ) == 1 : parser . print_help () sys . exit ( 0 ) else : args = parser . parse_args () return Option ( url = args . url , save_dir = args . save_dir , overwrite = args . overwrite , quiet = args . quiet , ) def _main ( test : list [ str ] | None = None ) -> None : \"\"\"Main function. Args: test (list[str] | None): test args. Defaults to None. \"\"\" opt = parse_args ( test ) if not opt . quiet : print ( f \"[+] Target: { opt . url . geturl () } \" ) print ( f \"[+] Host: { opt . url . hostname } \" ) print ( f \"[+] Slug: { opt . get_slug () } \" ) get_images ( opt ) if not opt . quiet : print ( \"[+] Done!\" ) def main () -> None : \"\"\"Main function.\"\"\" try : _main () except KeyboardInterrupt : sys . exit ( 1 ) if __name__ == \"__main__\" : main () Variables TYPE_CHECKING VALID_HOSTS Functions available_list def available_list ( ) -> 'str' Return available urls. Returns: Type Description str available urls. View Source def available_list () -> str : \"\"\"Return available urls. Returns: str: available urls. \"\"\" return \"available urls:\\n - https://\" + \"\\n - https://\" . join ( VALID_HOSTS ) check_dir def check_dir ( s : 'str' ) -> 'Path' Check if s is a valid directory. Parameters: Name Type Description Default s str path to check. None Returns: Type Description Path path object. Raises: Type Description argparse.ArgumentTypeError if s is not a directory. View Source def check_dir ( s : str ) -> Path : \"\"\"Check if s is a valid directory. Args: s (str): path to check. Raises: argparse.ArgumentTypeError: if s is not a directory. Returns: Path: path object. \"\"\" if s == \".\" : return Path (). cwd () path = Path ( s ) if not path . is_dir () : raise ArgumentTypeError ( f \"{s!r} is not dir.\" ) return path check_url def check_url ( s : 'str' ) -> 'ParseResult' Check if s is a valid url. Parameters: Name Type Description Default s str url to check. None Returns: Type Description ParseResult url object. Raises: Type Description argparse.ArgumentTypeError if s is invalid. View Source def check_url ( s : str ) -> ParseResult : \"\"\"Check if s is a valid url. Args: s (str): url to check. Raises: argparse.ArgumentTypeError: if s is invalid. Returns: ParseResult: url object. \"\"\" url = urlparse ( s ) if url . hostname in VALID_HOSTS and re . match ( \"^/manga/[^/]+/?$\" , url . path ) : return url raise ArgumentTypeError ( f \"' { s } ' is invalid.\\n\" + available_list ()) main def main ( ) -> 'None' Main function. View Source def main () -> None : \"\"\"Main function.\"\"\" try : _main () except KeyboardInterrupt : sys . exit ( 1 ) parse_args def parse_args ( test : 'list[str] | None' = None ) -> 'Option' Parse arguments. Parameters: Name Type Description Default test list[str] None test args. Defaults to None. Returns None Option: cli options. None Raises None ArgumentTypeError: if url is invalid. None View Source def parse_args ( test : list [ str ] | None = None ) -> Option : \"\"\"Parse arguments. Args: test (list[str] | None): test args. Defaults to None. Returns: Option: cli options. Raises: ArgumentTypeError: if url is invalid. \"\"\" parser = ArgumentParser ( formatter_class = ( lambda prog : CustomFormatter ( prog , width = get_terminal_size ( fallback = ( 120 , 50 )) . columns , max_help_position = 25 , ) ), description = \"Get and save images from webcomicgamma.\" , epilog = available_list (), ) parser . add_argument ( \"url\" , metavar = \"url\" , type = check_url , help = \"target url\" , ) parser . add_argument ( \"-d\" , \"--save-dir\" , type = check_dir , metavar = \"DIR\" , default = \".\" , help = \"directory to save downloaded images\" , ) parser . add_argument ( \"-o\" , \"--overwrite\" , action = \"store_true\" , help = \"overwrite\" , ) parser . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" , help = \"keep stdout quiet\" , ) parser . add_argument ( \"-V\" , \"--version\" , action = \"version\" , version = __version__ ) if test : args = parser . parse_args ( test ) if len ( sys . argv ) == 1 : parser . print_help () sys . exit ( 0 ) else : args = parser . parse_args () return Option ( url = args . url , save_dir = args . save_dir , overwrite = args . overwrite , quiet = args . quiet , ) Classes CustomFormatter class CustomFormatter ( prog , indent_increment = 2 , max_help_position = 24 , width = None ) Custom formatter for argparse. View Source class CustomFormatter ( ArgumentDefaultsHelpFormatter , RawDescriptionHelpFormatter ): \"\"\"Custom formatter for argparse.\"\"\" Ancestors (in MRO) argparse.ArgumentDefaultsHelpFormatter argparse.RawDescriptionHelpFormatter argparse.HelpFormatter Methods add_argument def add_argument ( self , action ) View Source def add_argument ( self , action ) : if action . help is not SUPPRESS : # find all invocations get_invocation = self . _format_action_invocation invocation_lengths = [ len(get_invocation(action)) + self._current_indent ] for subaction in self . _iter_indented_subactions ( action ) : invocation_lengths . append ( len ( get_invocation ( subaction )) + self . _current_indent ) # update the maximum item length action_length = max ( invocation_lengths ) self . _action_max_length = max ( self . _action_max_length , action_length ) # add the item to the list self . _add_item ( self . _format_action , [ action ] ) add_arguments def add_arguments ( self , actions ) View Source def add_arguments(self, actions): for action in actions: self.add_argument(action) add_text def add_text ( self , text ) View Source def add_text ( self , text ) : if text is not SUPPRESS and text is not None : self . _add_item ( self . _format_text , [ text ] ) add_usage def add_usage ( self , usage , actions , groups , prefix = None ) View Source def add_usage(self, usage, actions, groups, prefix=None): if usage is not SUPPRESS: args = usage, actions, groups, prefix self._add_item(self._format_usage, args) end_section def end_section ( self ) View Source def end_section(self): self._current_section = self._current_section.parent self._dedent() format_help def format_help ( self ) View Source def format_help(self): help = self._root_section.format_help() if help: help = self._long_break_matcher.sub('\\n\\n', help) help = help.strip('\\n') + '\\n' return help start_section def start_section ( self , heading ) View Source def start_section(self, heading): self._indent() section = self._Section(self, self._current_section, heading) self._add_item(section.format_help, []) self._current_section = section","title":"Main"},{"location":"reference/gettake/main/#module-gettakemain","text":"Main module for gettake. View Source \"\"\"Main module for gettake.\"\"\" from __future__ import annotations import re import sys from argparse import ( ArgumentDefaultsHelpFormatter , ArgumentParser , ArgumentTypeError , RawDescriptionHelpFormatter , ) from pathlib import Path from shutil import get_terminal_size from typing import TYPE_CHECKING from urllib.parse import urlparse from . import __version__ from .gettake import get_images from .models import Option if TYPE_CHECKING : from urllib.parse import ParseResult VALID_HOSTS = ( \"webcomicgamma.takeshobo.co.jp\" ,) class CustomFormatter ( ArgumentDefaultsHelpFormatter , RawDescriptionHelpFormatter ): \"\"\"Custom formatter for argparse.\"\"\" def available_list () -> str : \"\"\"Return available urls. Returns: str: available urls. \"\"\" return \"available urls: \\n - https://\" + \" \\n - https://\" . join ( VALID_HOSTS ) def check_url ( s : str ) -> ParseResult : \"\"\"Check if s is a valid url. Args: s (str): url to check. Raises: argparse.ArgumentTypeError: if s is invalid. Returns: ParseResult: url object. \"\"\" url = urlparse ( s ) if url . hostname in VALID_HOSTS and re . match ( \"^/manga/[^/]+/?$\" , url . path ): return url raise ArgumentTypeError ( f \"' { s } ' is invalid. \\n \" + available_list ()) def check_dir ( s : str ) -> Path : \"\"\"Check if s is a valid directory. Args: s (str): path to check. Raises: argparse.ArgumentTypeError: if s is not a directory. Returns: Path: path object. \"\"\" if s == \".\" : return Path () . cwd () path = Path ( s ) if not path . is_dir (): raise ArgumentTypeError ( f \" { s !r} is not dir.\" ) return path def parse_args ( test : list [ str ] | None = None ) -> Option : \"\"\"Parse arguments. Args: test (list[str] | None): test args. Defaults to None. Returns: Option: cli options. Raises: ArgumentTypeError: if url is invalid. \"\"\" parser = ArgumentParser ( formatter_class = ( lambda prog : CustomFormatter ( prog , width = get_terminal_size ( fallback = ( 120 , 50 )) . columns , max_help_position = 25 , ) ), description = \"Get and save images from webcomicgamma.\" , epilog = available_list (), ) parser . add_argument ( \"url\" , metavar = \"url\" , type = check_url , help = \"target url\" , ) parser . add_argument ( \"-d\" , \"--save-dir\" , type = check_dir , metavar = \"DIR\" , default = \".\" , help = \"directory to save downloaded images\" , ) parser . add_argument ( \"-o\" , \"--overwrite\" , action = \"store_true\" , help = \"overwrite\" , ) parser . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" , help = \"keep stdout quiet\" , ) parser . add_argument ( \"-V\" , \"--version\" , action = \"version\" , version = __version__ ) if test : args = parser . parse_args ( test ) if len ( sys . argv ) == 1 : parser . print_help () sys . exit ( 0 ) else : args = parser . parse_args () return Option ( url = args . url , save_dir = args . save_dir , overwrite = args . overwrite , quiet = args . quiet , ) def _main ( test : list [ str ] | None = None ) -> None : \"\"\"Main function. Args: test (list[str] | None): test args. Defaults to None. \"\"\" opt = parse_args ( test ) if not opt . quiet : print ( f \"[+] Target: { opt . url . geturl () } \" ) print ( f \"[+] Host: { opt . url . hostname } \" ) print ( f \"[+] Slug: { opt . get_slug () } \" ) get_images ( opt ) if not opt . quiet : print ( \"[+] Done!\" ) def main () -> None : \"\"\"Main function.\"\"\" try : _main () except KeyboardInterrupt : sys . exit ( 1 ) if __name__ == \"__main__\" : main ()","title":"Module gettake.main"},{"location":"reference/gettake/main/#variables","text":"TYPE_CHECKING VALID_HOSTS","title":"Variables"},{"location":"reference/gettake/main/#functions","text":"","title":"Functions"},{"location":"reference/gettake/main/#available_list","text":"def available_list ( ) -> 'str' Return available urls. Returns: Type Description str available urls. View Source def available_list () -> str : \"\"\"Return available urls. Returns: str: available urls. \"\"\" return \"available urls:\\n - https://\" + \"\\n - https://\" . join ( VALID_HOSTS )","title":"available_list"},{"location":"reference/gettake/main/#check_dir","text":"def check_dir ( s : 'str' ) -> 'Path' Check if s is a valid directory. Parameters: Name Type Description Default s str path to check. None Returns: Type Description Path path object. Raises: Type Description argparse.ArgumentTypeError if s is not a directory. View Source def check_dir ( s : str ) -> Path : \"\"\"Check if s is a valid directory. Args: s (str): path to check. Raises: argparse.ArgumentTypeError: if s is not a directory. Returns: Path: path object. \"\"\" if s == \".\" : return Path (). cwd () path = Path ( s ) if not path . is_dir () : raise ArgumentTypeError ( f \"{s!r} is not dir.\" ) return path","title":"check_dir"},{"location":"reference/gettake/main/#check_url","text":"def check_url ( s : 'str' ) -> 'ParseResult' Check if s is a valid url. Parameters: Name Type Description Default s str url to check. None Returns: Type Description ParseResult url object. Raises: Type Description argparse.ArgumentTypeError if s is invalid. View Source def check_url ( s : str ) -> ParseResult : \"\"\"Check if s is a valid url. Args: s (str): url to check. Raises: argparse.ArgumentTypeError: if s is invalid. Returns: ParseResult: url object. \"\"\" url = urlparse ( s ) if url . hostname in VALID_HOSTS and re . match ( \"^/manga/[^/]+/?$\" , url . path ) : return url raise ArgumentTypeError ( f \"' { s } ' is invalid.\\n\" + available_list ())","title":"check_url"},{"location":"reference/gettake/main/#main","text":"def main ( ) -> 'None' Main function. View Source def main () -> None : \"\"\"Main function.\"\"\" try : _main () except KeyboardInterrupt : sys . exit ( 1 )","title":"main"},{"location":"reference/gettake/main/#parse_args","text":"def parse_args ( test : 'list[str] | None' = None ) -> 'Option' Parse arguments. Parameters: Name Type Description Default test list[str] None test args. Defaults to None. Returns None Option: cli options. None Raises None ArgumentTypeError: if url is invalid. None View Source def parse_args ( test : list [ str ] | None = None ) -> Option : \"\"\"Parse arguments. Args: test (list[str] | None): test args. Defaults to None. Returns: Option: cli options. Raises: ArgumentTypeError: if url is invalid. \"\"\" parser = ArgumentParser ( formatter_class = ( lambda prog : CustomFormatter ( prog , width = get_terminal_size ( fallback = ( 120 , 50 )) . columns , max_help_position = 25 , ) ), description = \"Get and save images from webcomicgamma.\" , epilog = available_list (), ) parser . add_argument ( \"url\" , metavar = \"url\" , type = check_url , help = \"target url\" , ) parser . add_argument ( \"-d\" , \"--save-dir\" , type = check_dir , metavar = \"DIR\" , default = \".\" , help = \"directory to save downloaded images\" , ) parser . add_argument ( \"-o\" , \"--overwrite\" , action = \"store_true\" , help = \"overwrite\" , ) parser . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" , help = \"keep stdout quiet\" , ) parser . add_argument ( \"-V\" , \"--version\" , action = \"version\" , version = __version__ ) if test : args = parser . parse_args ( test ) if len ( sys . argv ) == 1 : parser . print_help () sys . exit ( 0 ) else : args = parser . parse_args () return Option ( url = args . url , save_dir = args . save_dir , overwrite = args . overwrite , quiet = args . quiet , )","title":"parse_args"},{"location":"reference/gettake/main/#classes","text":"","title":"Classes"},{"location":"reference/gettake/main/#customformatter","text":"class CustomFormatter ( prog , indent_increment = 2 , max_help_position = 24 , width = None ) Custom formatter for argparse. View Source class CustomFormatter ( ArgumentDefaultsHelpFormatter , RawDescriptionHelpFormatter ): \"\"\"Custom formatter for argparse.\"\"\"","title":"CustomFormatter"},{"location":"reference/gettake/main/#ancestors-in-mro","text":"argparse.ArgumentDefaultsHelpFormatter argparse.RawDescriptionHelpFormatter argparse.HelpFormatter","title":"Ancestors (in MRO)"},{"location":"reference/gettake/main/#methods","text":"","title":"Methods"},{"location":"reference/gettake/main/#add_argument","text":"def add_argument ( self , action ) View Source def add_argument ( self , action ) : if action . help is not SUPPRESS : # find all invocations get_invocation = self . _format_action_invocation invocation_lengths = [ len(get_invocation(action)) + self._current_indent ] for subaction in self . _iter_indented_subactions ( action ) : invocation_lengths . append ( len ( get_invocation ( subaction )) + self . _current_indent ) # update the maximum item length action_length = max ( invocation_lengths ) self . _action_max_length = max ( self . _action_max_length , action_length ) # add the item to the list self . _add_item ( self . _format_action , [ action ] )","title":"add_argument"},{"location":"reference/gettake/main/#add_arguments","text":"def add_arguments ( self , actions ) View Source def add_arguments(self, actions): for action in actions: self.add_argument(action)","title":"add_arguments"},{"location":"reference/gettake/main/#add_text","text":"def add_text ( self , text ) View Source def add_text ( self , text ) : if text is not SUPPRESS and text is not None : self . _add_item ( self . _format_text , [ text ] )","title":"add_text"},{"location":"reference/gettake/main/#add_usage","text":"def add_usage ( self , usage , actions , groups , prefix = None ) View Source def add_usage(self, usage, actions, groups, prefix=None): if usage is not SUPPRESS: args = usage, actions, groups, prefix self._add_item(self._format_usage, args)","title":"add_usage"},{"location":"reference/gettake/main/#end_section","text":"def end_section ( self ) View Source def end_section(self): self._current_section = self._current_section.parent self._dedent()","title":"end_section"},{"location":"reference/gettake/main/#format_help","text":"def format_help ( self ) View Source def format_help(self): help = self._root_section.format_help() if help: help = self._long_break_matcher.sub('\\n\\n', help) help = help.strip('\\n') + '\\n' return help","title":"format_help"},{"location":"reference/gettake/main/#start_section","text":"def start_section ( self , heading ) View Source def start_section(self, heading): self._indent() section = self._Section(self, self._current_section, heading) self._add_item(section.format_help, []) self._current_section = section","title":"start_section"},{"location":"reference/gettake/models/","text":"Module gettake.models Models for gettake. View Source \"\"\"Models for gettake.\"\"\" from __future__ import annotations from dataclasses import dataclass from typing import TYPE_CHECKING , Literal , TypedDict if TYPE_CHECKING : from pathlib import Path from urllib.parse import ParseResult @dataclass class Option : url : ParseResult save_dir : Path overwrite : bool quiet : bool def get_file_url ( self , chapter : str ) -> str : \"\"\"Get file url. Args: chapter (str): chapter name. Returns: str: file url. \"\"\" file_url = self . url . _replace ( path = f \"/_files/ { self . get_slug () } / { chapter } /data\" , ) return file_url . geturl () def get_slug ( self ) -> str : return self . url . path . rstrip ( \"/\" ) . split ( \"/\" )[ - 1 ] class ImageInfo ( TypedDict ): src : str width : int height : int class Resources ( TypedDict ): i : ImageInfo class View ( TypedDict ): width : int height : int coords : list [ str ] PositionOfImage = TypedDict ( \"PositionOfImage\" , { \"ptimg-version\" : Literal [ 1 ], \"resources\" : Resources , \"views\" : list [ View ], }, ) __all__ = ( \"Option\" , \"PositionOfImage\" ) Classes Option class Option ( url : 'ParseResult' , save_dir : 'Path' , overwrite : 'bool' , quiet : 'bool' ) Option(url: 'ParseResult', save_dir: 'Path', overwrite: 'bool', quiet: 'bool') View Source @dataclass class Option : url : ParseResult save_dir : Path overwrite : bool quiet : bool def get_file_url ( self , chapter : str ) -> str : \"\"\"Get file url. Args: chapter (str): chapter name. Returns: str: file url. \"\"\" file_url = self . url . _replace ( path = f \"/_files/{self.get_slug()}/{chapter}/data\" , ) return file_url . geturl () def get_slug ( self ) -> str : return self . url . path . rstrip ( \"/\" ). split ( \"/\" ) [ -1 ] Methods get_file_url def get_file_url ( self , chapter : 'str' ) -> 'str' Get file url. Parameters: Name Type Description Default chapter str chapter name. None Returns None str: file url. None View Source def get_file_url ( self , chapter : str ) -> str : \"\"\"Get file url. Args: chapter (str): chapter name. Returns: str: file url. \"\"\" file_url = self . url . _replace ( path = f \"/_files/{self.get_slug()}/{chapter}/data\" , ) return file_url . geturl () get_slug def get_slug ( self ) -> 'str' View Source def get_slug ( self ) -> str : return self . url . path . rstrip ( \"/\" ). split ( \"/\" )[ - 1 ] PositionOfImage class PositionOfImage ( / , * args , ** kwargs ) dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2) Ancestors (in MRO) builtins.dict Methods clear def clear ( ... ) D.clear() -> None. Remove all items from D. copy def copy ( ... ) D.copy() -> a shallow copy of D fromkeys def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value. get def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default. items def items ( ... ) D.items() -> a set-like object providing a view on D's items keys def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys pop def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError. popitem def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. setdefault def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. update def update ( ... ) D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E is present and has a .keys() method, then does: for k in E.keys(): D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] values def values ( ... ) D.values() -> an object providing a view on D's values","title":"Models"},{"location":"reference/gettake/models/#module-gettakemodels","text":"Models for gettake. View Source \"\"\"Models for gettake.\"\"\" from __future__ import annotations from dataclasses import dataclass from typing import TYPE_CHECKING , Literal , TypedDict if TYPE_CHECKING : from pathlib import Path from urllib.parse import ParseResult @dataclass class Option : url : ParseResult save_dir : Path overwrite : bool quiet : bool def get_file_url ( self , chapter : str ) -> str : \"\"\"Get file url. Args: chapter (str): chapter name. Returns: str: file url. \"\"\" file_url = self . url . _replace ( path = f \"/_files/ { self . get_slug () } / { chapter } /data\" , ) return file_url . geturl () def get_slug ( self ) -> str : return self . url . path . rstrip ( \"/\" ) . split ( \"/\" )[ - 1 ] class ImageInfo ( TypedDict ): src : str width : int height : int class Resources ( TypedDict ): i : ImageInfo class View ( TypedDict ): width : int height : int coords : list [ str ] PositionOfImage = TypedDict ( \"PositionOfImage\" , { \"ptimg-version\" : Literal [ 1 ], \"resources\" : Resources , \"views\" : list [ View ], }, ) __all__ = ( \"Option\" , \"PositionOfImage\" )","title":"Module gettake.models"},{"location":"reference/gettake/models/#classes","text":"","title":"Classes"},{"location":"reference/gettake/models/#option","text":"class Option ( url : 'ParseResult' , save_dir : 'Path' , overwrite : 'bool' , quiet : 'bool' ) Option(url: 'ParseResult', save_dir: 'Path', overwrite: 'bool', quiet: 'bool') View Source @dataclass class Option : url : ParseResult save_dir : Path overwrite : bool quiet : bool def get_file_url ( self , chapter : str ) -> str : \"\"\"Get file url. Args: chapter (str): chapter name. Returns: str: file url. \"\"\" file_url = self . url . _replace ( path = f \"/_files/{self.get_slug()}/{chapter}/data\" , ) return file_url . geturl () def get_slug ( self ) -> str : return self . url . path . rstrip ( \"/\" ). split ( \"/\" ) [ -1 ]","title":"Option"},{"location":"reference/gettake/models/#methods","text":"","title":"Methods"},{"location":"reference/gettake/models/#get_file_url","text":"def get_file_url ( self , chapter : 'str' ) -> 'str' Get file url. Parameters: Name Type Description Default chapter str chapter name. None Returns None str: file url. None View Source def get_file_url ( self , chapter : str ) -> str : \"\"\"Get file url. Args: chapter (str): chapter name. Returns: str: file url. \"\"\" file_url = self . url . _replace ( path = f \"/_files/{self.get_slug()}/{chapter}/data\" , ) return file_url . geturl ()","title":"get_file_url"},{"location":"reference/gettake/models/#get_slug","text":"def get_slug ( self ) -> 'str' View Source def get_slug ( self ) -> str : return self . url . path . rstrip ( \"/\" ). split ( \"/\" )[ - 1 ]","title":"get_slug"},{"location":"reference/gettake/models/#positionofimage","text":"class PositionOfImage ( / , * args , ** kwargs ) dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)","title":"PositionOfImage"},{"location":"reference/gettake/models/#ancestors-in-mro","text":"builtins.dict","title":"Ancestors (in MRO)"},{"location":"reference/gettake/models/#methods_1","text":"","title":"Methods"},{"location":"reference/gettake/models/#clear","text":"def clear ( ... ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"reference/gettake/models/#copy","text":"def copy ( ... ) D.copy() -> a shallow copy of D","title":"copy"},{"location":"reference/gettake/models/#fromkeys","text":"def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value.","title":"fromkeys"},{"location":"reference/gettake/models/#get","text":"def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default.","title":"get"},{"location":"reference/gettake/models/#items","text":"def items ( ... ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"reference/gettake/models/#keys","text":"def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"reference/gettake/models/#pop","text":"def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError.","title":"pop"},{"location":"reference/gettake/models/#popitem","text":"def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.","title":"popitem"},{"location":"reference/gettake/models/#setdefault","text":"def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.","title":"setdefault"},{"location":"reference/gettake/models/#update","text":"def update ( ... ) D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E is present and has a .keys() method, then does: for k in E.keys(): D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]","title":"update"},{"location":"reference/gettake/models/#values","text":"def values ( ... ) D.values() -> an object providing a view on D's values","title":"values"}]}